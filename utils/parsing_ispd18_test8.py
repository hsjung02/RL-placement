# -*- coding: utf-8 -*-
"""parsing_ispd18_test8.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pAVzjrVTzighgL47O1RMeIFrPpgdMmJP
"""
import math
import random
#global variables==============================================
canvas_grid_x_num = 32
canvas_grid_y_num = 32
canvas_x = 2716400/2000
canvas_y = 2650880/2000
grid_width =canvas_x/(canvas_grid_x_num)
grid_height=canvas_y/(canvas_grid_y_num)

hard_macro_num = 16 #adjacency index 0~15
soft_macro_num = 4800 #adjacency index 16~4815
pin_num = 1211 #adjacency index 4816~6026
std_num = 191987



std_width = 8
std_height = 1.2

soft_macro_size = math.sqrt((std_width*std_height) * 40)

partition_number = 4800
#=================================================================


def read_cells(filename):

  #각 macro들의 이름 및 크기 정보 가진 딕셔너리
  hard_macro_info={}
  std_info={}

  #각 macro들의 이름만 가진 배열
  hard_macro_name=[]
  std_name=[]

  macro_read_en=0

  #lef 파일로부터 넷리스트에 포함된 macro들의 정보 읽어오기=========================

  with open(filename + '.lef') as n:

    for num, line in enumerate(n):

      if '#' in line:
        continue


      if 'MACRO' in line: #새로운 macro 종류 등장
        macro_read_en=1 
        ismacro = 0 #1일경우 hard macro, 0일경우 std
        data = line.split()
        macro_name = data[1]

      #macro 정보가 아닌 곳에서 size읽어오면 안되므로 enable 신호 사용
      if macro_read_en: 

        #macro가 hard macro인지 std인지 분류====================
        if 'CLASS' in line: 
          data = line.split()
          if(data[1]=='BLOCK'):
            ismacro = 1 #hard macro
          else:
            ismacro = 0 #standard cell
        #=========================================================

        
        elif 'BY' in line:
          data = line.split()
          macro_width = data[1]
          macro_height = data[3]

          if(ismacro): #hard macro일 경우
            hard_macro_info[macro_name] = {'width' : float(macro_width), 'height' : float(macro_height)}

            hard_macro_name.append(macro_name)

          else: #std일 경우
            try:
              std_info[macro_name] =  {'width' : float(macro_width), 'height' : float(macro_height)}


            except ValueError:
              std_info[macro_name] = {'width' : float(data[2]), 'height' : float(data[4])}


            std_name.append(macro_name)

  #=====================================================================================


  #def파일로부터 핀 읽어오기============================================================
  
  pins={}
  read_pin_en=0
  pin_adjacency_index = hard_macro_num+soft_macro_num
  with open(filename + '.def') as n:
    for num, line in enumerate(n):
      #pin read enable==================
      if 'END PINS' in line:
        read_pin_en = 0
      elif 'PINS' in line:
        read_pin_en = 1
      #==================================
      
      
      if(read_pin_en):
        if '- pin' in line:
          data = line.split()
          pin_name = data[1] #pin의 이름
          pin_connected_net = data[4] #pin이 어떤 net에 연결되어 있는지
        elif 'PLACED' in line:
          data = line.split()

          #um단위
          pin_x = int(data[3])/2000
          pin_y = int(data[4])/2000

          #(0 0) ( 2716400 0 ) ( 0 2650880 ) ( 2716400 2650880 )와 같이 꼭짓점에는 핀이 없당

          #핀리스트에 추가
          pins[pin_name] = {'connected_net' : pin_connected_net, 'adjacency_index':pin_adjacency_index, 'x':pin_x, 'y':pin_y}
          pin_adjacency_index = pin_adjacency_index+1



  #=====================================================================================


        
  #def 파일로부터 component의 이름 읽어오기=======================================

  hard_macros = {}
  stds = {}

  #initialize
  hard_macro_adjacency_index = 0
  
  read_component_en=0
  std_hmetis_index=1 

  with open(filename + '.def') as n:
    for num, line in enumerate(n):
      #component read enable=============
      if 'END COMPONENTS' in line:
        read_component_en = 0
      elif 'COMPONENTS' in line:
        read_component_en = 1
      #==================================

      if(read_component_en):
        if('- ') in line:
          data = line.split()
          component_name = data[1] #각 component의 이름
          component_macro_name = data[2] #각 component가 어떤 매크로인지지


          #component_macro_name이 hard_macro_name에 속해있는 경우
          if component_macro_name in hard_macro_name:
            random_place_x = random.random() * canvas_x
            random_place_y = random.random() * canvas_y
            hard_macros[component_name] = {'connected_nets' : [], 'adjacency_index':hard_macro_adjacency_index, 'x': random_place_x, 'y':random_place_y}
            hard_macro_adjacency_index = hard_macro_adjacency_index + 1
          #component_macro_name이 std_name에 속해있는 경우
          elif component_macro_name in std_name:
            stds[component_name] = {'connected_nets' : [], 'hmetis_index': std_hmetis_index}
            std_hmetis_index=std_hmetis_index+1


  return hard_macros, stds, pins, hard_macro_name, std_name

def read_nets(filename, hard_macros, stds, pins, hard_macro_name, std_name):

  read_net_en=0
  net_list = {}
  pin_adjacency_index = hard_macro_num + soft_macro_num
  
  with open(filename + '.def') as n:
    for num, line in enumerate(n):

      #net read enable===================
      if 'END NETS' in line:
        read_net_en = 0
      elif 'NETS' in line:
        read_net_en = 1
      #==================================

      if(read_net_en):
        #새로운 net 등장
        if '-' in line:
          data = line.split()
          net_name = data[1] #net의 이름
          
          net_list[net_name] = {'connected_stds': [], 'connected_hard_macros' :[], 'connected_soft_macros' :[],'connected_pins' :[], 'connected_adjacency_indices':[]}
        else:
          data = line.split()
          #해당 net에 포함된 pin 및 component들 추가====
          for component_name in data: 
            if 'pin' in component_name: 
              net_list[net_name]['connected_pins'].append(component_name)
              net_list[net_name]['connected_adjacency_indices'].append(pins[component_name]['adjacency_index'])
              

            elif 'inst' in component_name:
              if component_name in hard_macros: #hard macro
                hard_macros[component_name]['connected_nets'].append(net_name)  #cell list 내의 net update
                net_list[net_name]['connected_hard_macros'].append(component_name)  #net list update
                net_list[net_name]['connected_adjacency_indices'].append(hard_macros[component_name]['adjacency_index'])



              elif component_name in stds: #std
                stds[component_name]['connected_nets'].append(net_name)  #cell list 내의 net update
                net_list[net_name]['connected_stds'].append(component_name)  #net list update

          #==============================================
          
  print("pin_adjacency_index", pin_adjacency_index)

  return net_list

def make_HGraphFile(filename, net_list, stds):
  

  f=open("./netlist/HGraphFile.txt", 'w')

  #write the information of graph at the top
  info_data="%d %d\n" % (len(net_list), len(stds)+1)
  f.write(info_data) 

  
  for net_name in net_list:
    data=""
    for std_name in net_list[net_name]['connected_stds']:
      data = data + str(stds[std_name]['hmetis_index']) + ' '
    data=data+'\n'
    if(data=='\n'):
      data = "%d\n" % (len(stds)+1)  #hard macro만 포함된  net의 모든 hard macro는 191988번째 std로 가정(hmetis 오류 방지용)
      
    f.write(data)
    
  f.close()

def make_softmacros(partition_num, stds, hard_macros):
  
  
  #빠른 서치를 위해 hmetis_indices 만들기============
  hmetis_indices_std_name = [i for i in range(len(stds)+1)]
  
  i=1
  for std_name in stds:
    if(stds[std_name]['hmetis_index']==i):
      hmetis_indices_std_name[i]=std_name
      i = i+1
      
  #=================================================
  
  
  soft_macros = {}
  soft_macro_count = 0
  soft_macro_adjacency_index = hard_macro_num
  print("making soft macros start!")
  with open('./netlist/HGraphFile.hgr.part.'+str(partition_num)) as n:

    for num,line in enumerate(n):
      data = line.split()
      soft_macro_hmetis_name = data[0]
      #print("line num: ", num)  
      
      if(num>=191987):
        break
      
      else:
        soft_macro_name = 'softmacro' + soft_macro_hmetis_name #소프트매크로의 이름
        
        
        net_append_enable=0
        if(soft_macro_name in soft_macros):
          #num번째(num은 0부터 시작) 줄에 작성된 정보는 num+1번 hmetis index를 갖는 std cell이 속한 soft macro를 나타낸다. 
          std_hmetis_index = num+1
          soft_macros[soft_macro_name]['clustered_stds'].append(hmetis_indices_std_name[std_hmetis_index])

          
          
          for std_name in soft_macros[soft_macro_name]['clustered_stds']:
              soft_macros[soft_macro_name]['connected_nets'] = soft_macros[soft_macro_name]['connected_nets'] + stds[std_name]['connected_nets']

          
        
          
          
        #처음 등장한 softmacro일 경우
        else:
          
          #print("soft macro count : ", soft_macro_count)
          soft_macros[soft_macro_name] = {'connected_nets': [], 'adjacency_index': soft_macro_adjacency_index, 'clustered_stds':[], 'size':soft_macro_size, 
                                          'x' : 0, 'y' : 0, 'ePlace_grid_x' : 0, 'ePlace_grid_y' : 0, 
                                          'attraction_x' : 0, 'attraction_y' : 0, 'repulsion_x':0, 'repulsion_y' : 0, 'electric_force_x':0, 'electric_force_y' : 0}
          soft_macro_count = soft_macro_count+1
          soft_macro_adjacency_index = soft_macro_adjacency_index + 1
  
  
  
  for soft_macro_name in soft_macros:
    for net_name in soft_macros[soft_macro_name]['connected_nets']:
      net_list[net_name]['connected_soft_macros'].append(soft_macro_name)
      
      if(soft_macro_adjacency_index in net_list[net_name]['connected_adjacency_indices']):
        continue
      else:
        net_list[net_name]['connected_adjacency_indices'].append(soft_macro_adjacency_index)
    soft_macro_adjacency_index = soft_macro_adjacency_index+1

  #print("soft_macro_adjacency_index : ", soft_macro_adjacency_index)
  print("making soft macros finish!")
  return soft_macros


def make_adjacency_matrix(net_list, hard_macros, soft_macros, pins, total_data_num):
  

  adjacency_matrix = [[0 for i in range(total_data_num)] for j in range(total_data_num)]

  #hard macro, soft macro, pin에 adjacency index 부여
  adjacency_indices_component_name = [0 for i in range(total_data_num)]
  
  '''
  adjacency_index=0
  for hard_macro_name in hard_macros:
    hard_macros[hard_macro_name]['adjacency_index'] = adjacency_index
    adjacency_indices_component_name[adjacency_index] = hard_macro_name
    adjacency_index=adjacency_index+1

  for soft_macro_name in soft_macros:
    soft_macros[soft_macro_name]['adjacency_index'] = adjacency_index
    adjacency_indices_component_name[adjacency_index] = soft_macro_name
    adjacency_index = adjacency_index+1

  for pin_name in pins:
    pins[pin_name]['adjacency_index'] = adjacency_index
    adjacency_indices_component_name[adjacency_index] = pin_name
    adjacency_index = adjacency_index+1'''

  
  
  net_count = 0
  print("making adjacency matrix start!")
  for net_name in net_list:
    #print("net_count : ", net_count)
    #print("net_length : ", len(net_list[net_name]['connected_adjacency_indices']))
    for index_x in net_list[net_name]['connected_adjacency_indices']:
      for index_y in net_list[net_name]['connected_adjacency_indices']:
        adjacency_matrix[index_x][index_y] = 1
    net_count = net_count+1
    '''
    #해당 net과 연결된 hard macro 탐색===================================================
    for hard_macro_name1 in net_list[net_name]['connected_hard_macros']:
      index1 = hard_macros[hard_macro_name1]['adjacency_index'];

      for hard_macro_name2 in net_list[net_name]['connected_hard_macros']:
        index2 = hard_macros[hard_macro_name2]['adjacency_index'];
        adjacency_matrix[index1][index2]=1

      for soft_macro_name2 in net_list[net_name]['connected_soft_macros']:
        index2 = soft_macros[soft_macro_name2]['adjacency_index'];
        adjacency_matrix[index1][index2]=1

      for pin_name2 in net_list[net_name]['connected_pins']:
        index2 = pins[pin_name2]['adjacency_index'];
        adjacency_matrix[index1][index2]=1
    #===================================================================================

    #해당 net과 연결된 soft macro 탐색===================================================
    for soft_macro_name1 in net_list[net_name]['connected_soft_macros']:
      index1 = soft_macros[soft_macro_name1]['adjacency_index'];

      for hard_macro_name2 in net_list[net_name]['connected_hard_macros']:
        index2 = hard_macros[hard_macro_name2]['adjacency_index'];
        adjacency_matrix[index1][index2]=1

      for soft_macro_name2 in net_list[net_name]['connected_soft_macros']:
        index2 = soft_macros[soft_macro_name2]['adjacency_index'];
        adjacency_matrix[index1][index2]=1

      for pin_name2 in net_list[net_name]['connected_pins']:
        index2 = pins[pin_name2]['adjacency_index'];
        adjacency_matrix[index1][index2]=1
    #===================================================================================

    #해당 net과 연결된 pin 탐색==========================================================
    for pin_name1 in net_list[net_name]['connected_pins']:
      index1 = pins[pin_name1]['adjacency_index'];

      for hard_macro_name2 in net_list[net_name]['connected_hard_macros']:
        index2 = hard_macros[hard_macro_name2]['adjacency_index'];
        adjacency_matrix[index1][index2]=1

      for soft_macro_name2 in net_list[net_name]['connected_soft_macros']:
        index2 = soft_macros[soft_macro_name2]['adjacency_index'];
        adjacency_matrix[index1][index2]=1

      for pin_name2 in net_list[net_name]['connected_pins']:
        index2 = pins[pin_name2]['adjacency_index'];
        adjacency_matrix[index1][index2]=1
    #===================================================================================
    '''

  for i in range(len(adjacency_matrix)):
    adjacency_matrix[i][i] = 0
  
  
  #print("making adjacency matrix finish!")
  return adjacency_matrix


#call functions====================================================================================================================
filename = './netlist/ispd18_test8.input'

#before clustering==========
hard_macros, stds, pins, hard_macro_name, std_name = read_cells(filename)
net_list = read_nets(filename, hard_macros, stds, pins, hard_macro_name, std_name)
make_HGraphFile(filename, net_list,stds)


print("parsing finish!")


#after clustering=========
soft_macros = make_softmacros(partition_number, stds, hard_macros)
total_data_num = len(hard_macros)+len(soft_macros)+len(pins)
adjacency_matrix = make_adjacency_matrix(net_list, hard_macros, soft_macros, pins, total_data_num)


print("making adjacency matrix finish!")


#ePlace(adjacency_matrix, hard_macros, soft_macros, pins, net_list)
#==================================================================================================================================

'''import pickle

with open("./netlist/adjacency_matrix", "wb") as f:
    pickle.dump(adjacency_matrix, f)

with open("./netlist/cells", "wb") as f:
    pickle.dump(cells, f)

with open("./netlist/macro_indices", "wb") as f:
    pickle.dump(macro_indices, f)

with open("./netlist/std_indices", "wb") as f:
    pickle.dump(std_indices, f)'''